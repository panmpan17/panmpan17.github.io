<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    
    <style>
        body {
            background-color: #bababa;

        }
        canvas#gameCanvas {
            /* background-color: #f0f0f0; */
            display: block;
            margin: 0 auto;
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script src="/javascript/game/math.js"></script>
    <script src="/javascript/game/draw.js"></script>
    <script>
        let images = {};
        let FPS = 60;

        function loadImage(name, src) {
            return new Promise((resolve, reject) => {
                images[name] = new Image();
                images[name].src = src;
                images[name].onload = () => {
                    resolve(images[name]);
                };
                images[name].onerror = () => reject(new Error(`Failed to load image: ${src}`));
            });
        }

        class SimpleImageNode {
            constructor({image, x, y, scale}) {
                this.image = image;
                this.pos = new Vector(x, y);
                this.scale = scale || 1;
                this.rotation = 0; // In radians
            }

            update(gameCanvas, deltaTime) {}

            draw(gameCanvas) {
                let width = this.image.width * this.scale;
                let height = this.image.height * this.scale;
                gameCanvas.context.save();
                gameCanvas.context.translate(this.pos.x, this.pos.y);
                gameCanvas.context.rotate(this.rotation);
                gameCanvas.context.drawImage(this.image, -width / 2, -height / 2, width, height);
                gameCanvas.context.restore();
            }
        }

        class Ship extends SimpleImageNode {
            constructor(x, y) {
                super({ image: images.ship, x, y, scale: 0.8 });

                this.velocity = new Vector(0, 0);
                this.mouseDown = false;

                this.flySpeed = 10;
                this.accelerationSpeed = 50;
                this.drag = 20;
            }

            update(gameCanvas, deltaTime) {
                let isMoving = false;
                if (gameCanvas.mouseDown && gameCanvas.mouseInFrame) {
                    isMoving = this.updateVelocity(gameCanvas, deltaTime);
                }

                if (!isMoving) {
                    // Apply drag effect when not moving
                    this.velocity = this.velocity.moveTowards(VectorZero, this.drag * deltaTime);
                }

                this.pos = this.pos.add(this.velocity.multiply(deltaTime));
            }

            updateVelocity(gameCanvas, deltaTime) {
                let delta = gameCanvas.mousePositionWorld.subtract(this.pos);
                let targetRotation = delta.getAngleInRadians() + (3.14 / 2);

                this.rotation = rotateRadianTowards(this.rotation, targetRotation, 0.1);

                if (delta.sqrMagnitude() > 0.01) {
                    let clamedDelta = delta.clampMagnitude(100);
                    let targetVelocity = clamedDelta.multiply(this.flySpeed); // Speed factor
                    this.velocity = this.velocity.moveTowards(targetVelocity, this.accelerationSpeed * deltaTime);

                    // TODO: Add effect for drag point
                    return true;
                }

                return false;
            }

            draw(gameCanvas) {
                super.draw(gameCanvas);

                drawText(gameCanvas.context, round(this.rotation), 10, 50);
                drawText(gameCanvas.context, `${round(this.velocity.x)}, ${round(this.velocity.y)}`, 10, 70);

                let delta = gameCanvas.mousePositionWorld.subtract(this.pos);

                if (gameCanvas.mouseInFrame && gameCanvas.mouseDown) {
                    let clamedDelta = delta.clampMagnitude(100);
                    let pos = this.pos.add(clamedDelta);
                    drawCircle(gameCanvas.context, pos.x, pos.y, 5, 'red');
                }
            }
        }

        class GameCanvas {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.context = this.canvas.getContext('2d');

                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseenter', this.onMouseEnter.bind(this));
                this.canvas.addEventListener('mouseleave', this.onMouseLeave.bind(this));


                this.mouseInFrame = false;
                this.mousePosition = new Vector(0, 0);
                this.mousePositionWorld = new Vector(0, 0);
                this.mouseDown = false;

                this.lastTime = null;

                this.children = [
                    new Ship(this.canvas.width / 2, this.canvas.height / 2),
                ];
            }

            start() {
                this.lastTime = Date.now();
                setInterval(() => {
                    this.update();
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    for (let i = 0; i < this.children.length; i++) {
                        this.children[i].draw(this);
                    }
                }, 1000 / FPS);
            }

            update() {
                // Update game state
                let now = Date.now();
                let deltaTime = (now - this.lastTime) / 1000; // Convert
                
                for (let i = 0; i < this.children.length; i++) {
                    this.children[i].update(this, deltaTime);
                }

                this.lastTime = now;
            }

            onMouseEnter(event) {
                this.mouseInFrame = true;
            }
            onMouseLeave(event) {
                this.mouseInFrame = false;
            }
            onMouseDown(event) {
                this.mouseDown = true;
            }
            onMouseUp(event) {
                this.mouseDown = false;
                
            }
            onMouseMove(event) {
                this.mousePosition.x = event.offsetX;
                this.mousePosition.y = event.offsetY;
                this.mousePositionWorld.x = this.mousePosition.x; // Adjust if needed for world coordinates
                this.mousePositionWorld.y = this.mousePosition.y; // Adjust if needed for world coordinates
            }
        }

        (function() {

            // Load images
            Promise.all([
                loadImage('ship', '/images/game/ship.png'),
                // Add more images as needed
            ]).then(() => {
                console.log('All images loaded successfully');
                var gameCanvas = new GameCanvas();
                gameCanvas.start();
            }).catch(error => {
                console.error(error);
            });
        })();
    </script>
</body>
</html>